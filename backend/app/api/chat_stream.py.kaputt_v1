"""
Streaming Chat API with WebSocket
Real-time AI response streaming for better UX
"""
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException
from typing import Dict, Set
import json
import asyncio
import logging
from datetime import datetime, timezone

from ..core.ai_manager import AIManager
from ..core.database import get_db_session as get_database

logger = logging.getLogger(__name__)
router = APIRouter()


class ConnectionManager:
    """Manages WebSocket connections for streaming"""
    
    def __init__(self):
        self.active_connections: Dict[str, Set[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, session_id: str):
        """Accept and store WebSocket connection"""
        await websocket.accept()
        if session_id not in self.active_connections:
            self.active_connections[session_id] = set()
        self.active_connections[session_id].add(websocket)
        logger.info(f"‚úÖ WebSocket connected: {session_id}")
    
    def disconnect(self, websocket: WebSocket, session_id: str):
        """Remove WebSocket connection"""
        if session_id in self.active_connections:
            self.active_connections[session_id].discard(websocket)
            if not self.active_connections[session_id]:
                del self.active_connections[session_id]
        logger.info(f"‚ùå WebSocket disconnected: {session_id}")
    
    async def send_message(self, message: dict, session_id: str):
        """Send message to all connections in a session"""
        if session_id in self.active_connections:
            disconnected = set()
            for connection in self.active_connections[session_id]:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    logger.error(f"Error sending message: {e}")
                    disconnected.add(connection)
            
            # Clean up disconnected sockets
            for conn in disconnected:
                self.disconnect(conn, session_id)


# Global connection manager
manager = ConnectionManager()


@router.websocket("/ws/chat/{session_id}")
async def websocket_chat_endpoint(websocket: WebSocket, session_id: str):
    """
    WebSocket endpoint for streaming chat with Keep-Alive
    
    Expected message format:
    {
        "type": "chat",
        "content": "user message",
        "provider": "anthropic",
        "model": "claude-sonnet-4",
        "ultra_thinking": false,
        "api_keys": {...}
    }
    
    Keep-Alive: Automatic ping every 30 seconds to prevent connection drops
    """
    # Check origin header for CORS (WebSocket doesn't use CORS middleware)
    # Note: WebSocket headers are case-sensitive, check both cases
    origin = websocket.headers.get("Origin", "") or websocket.headers.get("origin", "")
    logger.info(f"WebSocket connection attempt - Origin: '{origin}', Headers: {dict(websocket.headers)}")
    
    allowed_origins = [
        "http://localhost:3000",
        "http://localhost:3001",
        "http://localhost:3002",
        "http://localhost:5173",
        "http://127.0.0.1:3000",
        "http://127.0.0.1:3001",
        "http://127.0.0.1:3002",
        "http://127.0.0.1:5173",
    ]
    
    # Allow connections from allowed origins or when origin is empty (same-origin)
    if origin and origin not in allowed_origins:
        logger.warning(f"WebSocket connection rejected: Invalid origin '{origin}' not in {allowed_origins}")
        await websocket.close(code=1008, reason="Origin not allowed")
        return
    
    logger.info(f"WebSocket origin check passed for origin: '{origin}'")
    
    # Accept WebSocket connection
    try:
        await manager.connect(websocket, session_id)
    except Exception as e:
        logger.error(f"Failed to accept WebSocket: {e}")
        return
    
    try:
        while True:
            # Receive message from client
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            if message_data.get("type") == "ping":
                # Heartbeat
                await websocket.send_json({"type": "pong"})
                continue
            
            if message_data.get("type") != "chat":
                continue
            
            # Extract message details
            user_message = message_data.get("content", "")
            provider = message_data.get("provider", "openai")
            model = message_data.get("model", "gpt-4o-mini")
            ultra_thinking = message_data.get("ultra_thinking", False)
            api_keys = message_data.get("api_keys", {})
            conversation_history = message_data.get("messages", [])
            
            # Debug logging for API keys
            logger.info(f"üîç WebSocket received - Provider: {provider}, Model: {model}")
            logger.info(f"üîç API keys received from frontend: {list(api_keys.keys())}")
            logger.info(f"üîç API key for {provider}: {'‚úÖ Present' if api_keys.get(provider) else '‚ùå Missing'}")
            
            # CRITICAL FIX: Auto-load API keys from database if missing
            if not api_keys.get(provider):
                logger.warning(f"‚ö†Ô∏è API key for {provider} not sent from frontend - loading from database")
                try:
                    from ..models.api_key_models import UserApiKey
                    from ..core.encryption import encryption_manager
                    
                    # Get user ID from session
                    db = get_database()
                    try:
                        # Try to get user_id from session first
                        from ..models.session_models import Session
                        session_obj = db.query(Session).filter(Session.id == session_id).first()
                        user_id = session_obj.user_id if session_obj else None
                        
                        # If no user_id in session, try to extract from session_id (format: user123_session456)
                        if not user_id and '_' in session_id:
                            user_id = session_id.split('_')[0]
                        
                        # If still no user_id, use first available user (demo mode)
                        if not user_id:
                            from ..models.user_models import User
                            first_user = db.query(User).first()
                            user_id = first_user.id if first_user else None
                        
                        logger.info(f"üîç Loading API keys for user: {user_id}")
                        
                        # Load all stored API keys for this user
                        if user_id:
                            user_api_keys = db.query(UserApiKey).filter(
                                UserApiKey.user_id == user_id,
                                UserApiKey.is_active == True
                            ).all()
                        else:
                            # No user found, load any available keys
                            user_api_keys = db.query(UserApiKey).filter(
                                UserApiKey.is_active == True
                            ).all()
                        
                        # Decrypt and add to api_keys dict
                        loaded_count = 0
                        for key_record in user_api_keys:
                            try:
                                decrypted_key = encryption_manager.decrypt(key_record.encrypted_key)
                                api_keys[key_record.provider] = decrypted_key
                                loaded_count += 1
                                logger.info(f"‚úÖ Loaded {key_record.provider} API key from database")
                            except Exception as decrypt_error:
                                logger.error(f"‚ùå Failed to decrypt {key_record.provider} key: {decrypt_error}")
                        
                        if loaded_count > 0:
                            logger.info(f"‚úÖ Successfully loaded {loaded_count} API key(s) from database")
                        else:
                            logger.warning(f"‚ö†Ô∏è No API keys found in database")
                    
                    finally:
                        db.close()
                
                except Exception as e:
                    logger.error(f"‚ùå Failed to auto-load API keys from database: {e}")
                    import traceback
                    traceback.print_exc()
            
            # CRITICAL: Load active project context with simplified user_id detection
            project_context = None
            user_id = None
            
            db = get_database()
            try:
                # SCHRITT 1: Versuche user_id und project aus Session zu holen
                from ..models.session_models import Session
                session_obj = db.query(Session).filter(Session.id == session_id).first()
                
                if session_obj:
                    user_id = session_obj.user_id
                    logger.info(f"üîç User ID from session: {user_id}")
                    
                    # Lade active project aus Session
                    if session_obj.active_project:
                        project_context = {
                            "project_name": session_obj.active_project,
                            "branch": session_obj.active_project_branch or "main",
                            "working_directory": f"/app/{session_obj.active_project}"
                        }
                        logger.info(f"‚úÖ Active project from session: {session_obj.active_project}")
                
                # SCHRITT 2: Falls keine user_id in Session, versuche aus session_id zu extrahieren
                if not user_id and '_' in session_id:
                    potential_user_id = session_id.split('_')[0]
                    from ..models.user_models import User
                    user_exists = db.query(User).filter(User.id == potential_user_id).first()
                    
                    if user_exists:
                        user_id = potential_user_id
                        logger.info(f"‚úÖ User ID extracted from session_id: {user_id}")
                
                # SCHRITT 3: Falls immer noch keine user_id, verwende ersten verf√ºgbaren User
                if not user_id:
                    logger.warning(f"‚ö†Ô∏è No user_id found, using first available user (demo mode)")
                    from ..models.user_models import User
                    first_user = db.query(User).first()
                    
                    if first_user:
                        user_id = first_user.id
                        logger.info(f"‚úÖ Using first user: {user_id}")
                
                # FINAL: Logging
                if project_context:
                    logger.info(f"‚úÖ Active project loaded for user {user_id}: {project_context['project_name']}")
                else:
                    logger.warning(f"‚ö†Ô∏è No active project set for session {session_id}")
            
            except Exception as e:
                logger.error(f"‚ùå Failed to load project context: {e}")
                import traceback
                traceback.print_exc()
            finally:
                db.close()
            
            # Add user message to history
            conversation_history.append({
                "role": "user",
                "content": user_message
            })
            
            # Send acknowledgment
            await manager.send_message({
                "type": "start",
                "session_id": session_id,
                "timestamp": datetime.now(timezone.utc).isoformat()
            }, session_id)
            
            try:
                # Initialize AI Manager
                ai_manager = AIManager()
                
                # Stream AI response
                full_response = ""
                chunk_count = 0
                
                # Pass api_keys and project_context to stream_response
                async for chunk in ai_manager.stream_response(
                    provider=provider,
                    model=model,
                    messages=conversation_history,
                    ultra_thinking=ultra_thinking,
                    api_keys=api_keys,
                    project_context=project_context
                ):
                    chunk_count += 1
                    chunk_text = chunk.get("content", "")
                    full_response += chunk_text
                    
                    # Send chunk to client
                    await manager.send_message({
                        "type": "chunk",
                        "content": chunk_text,
                        "chunk_id": chunk_count
                    }, session_id)
                    
                    # Small delay to prevent overwhelming client
                    await asyncio.sleep(0.01)
                
                # Send completion message
                # Get token usage stats
                from ..core.token_tracker import token_tracker
                token_stats = token_tracker.get_usage_stats()
                
                await manager.send_message({
                    "type": "complete",
                    "full_content": full_response,
                    "model": model,
                    "provider": provider,
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                    "token_usage": token_stats  # NEW: Include token usage
                }, session_id)
                
                # Save to SQLite
                db = get_database()
                
                try:
                    from ..models.session_models import Message, Session
                    import uuid
                    
                    # Check if session exists, create if not
                    session = db.query(Session).filter(Session.id == session_id).first()
                    if not session:
                        # Create session if it doesn't exist
                        new_session = Session(
                            id=session_id,
                            name="Chat Session",
                            user_id=None  # Will be set later if authenticated
                        )
                        db.add(new_session)
                        db.commit()
                    
                    # Save user message
                    user_msg = Message(
                        id=f"msg_{uuid.uuid4().hex[:16]}",
                        session_id=session_id,
                        role="user",
                        content=user_message,
                        provider=provider,
                        model=model
                    )
                    db.add(user_msg)
                    
                    # Save assistant message
                    assistant_msg = Message(
                        id=f"msg_{uuid.uuid4().hex[:16]}",
                        session_id=session_id,
                        role="assistant",
                        content=full_response,
                        provider=provider,
                        model=model
                    )
                    db.add(assistant_msg)
                    
                    db.commit()
                    logger.info(f"‚úÖ Messages saved to database")
                    
                except Exception as e:
                    logger.error(f"‚ùå Error saving messages to database: {e}")
                    db.rollback()
                finally:
                    if "db" in locals() and db is not None:
                        db.close()
                
                logger.info(f"‚úÖ Streaming complete: {chunk_count} chunks, {len(full_response)} chars")
                
            except ValueError as e:
                # Handle configuration errors (missing API keys)
                error_message = str(e)
                logger.warning(f"‚ö†Ô∏è Configuration error: {error_message}")
                
                # Send user-friendly error message
                await manager.send_message({
                    "type": "error",
                    "message": "‚ö†Ô∏è API Key Not Configured",
                    "details": f"{error_message}\n\nüìù Please configure your API keys:\n1. Click on Settings (‚öôÔ∏è)\n2. Scroll to 'AI Provider API Keys'\n3. Add your API key for {provider}\n4. Click 'Save API Keys'\n5. Return to chat and try again",
                    "action_required": "configure_api_keys",
                    "provider": provider,
                    "timestamp": datetime.now(timezone.utc).isoformat()
                }, session_id)
                
            except Exception as e:
                logger.error(f"Streaming error: {e}")
                await manager.send_message({
                    "type": "error",
                    "message": "An error occurred while processing your message",
                    "details": str(e),
                    "timestamp": datetime.now(timezone.utc).isoformat()
                }, session_id)
    
    except WebSocketDisconnect:
        manager.disconnect(websocket, session_id)
        logger.info(f"Client disconnected: {session_id}")
    
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
        manager.disconnect(websocket, session_id)


@router.get("/stream/status")
async def get_stream_status():
    """Get streaming service status"""
    return {
        "status": "active",
        "active_sessions": len(manager.active_connections),
        "total_connections": sum(len(conns) for conns in manager.active_connections.values())
    }
